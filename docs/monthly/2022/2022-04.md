# 4월 목표 
- 블로그 만들기


# 읽어볼 것 
- <https://ui.toast.com/weekly-pick/ko_20191014>

# 0401 FRI

- [X] 블로그 구색완료하기
	: 이걸 구색완료했다고 해야할까? 
- [ ] 영어공부 : underdash 적혀있는 영어글들 번역해보기
- [ ] 과제 시작하기

mdx가 뭐지 ? 
따라하던 블로그 유튜브 강좌 ...툴이 업데이트돼서 무용지물이 되버림

code ERESOLVE 
--legacy-peer-deps 명령어 사용 

<https://blog.jetbrains.com/webstorm/2021/10/building-a-blog-with-next-js-and-mdx/>
<https://blog.logrocket.com/create-next-js-mdx-blog/>
이 블로그 만들면 밑에 글도 이해할 수 있는거냐? 
<https://dev.to/largonarco/how-to-setup-a-dev-blog-using-nextjs-and-next-mdx-remote-4mb9>


## 재귀함수 Recursion
피버나치 
Termination Case가 꼭 있어야 한다. 
콜스택!! 

2주차 과제 시작해야지~

이번주는 자료구조에 대한 과제

## 0403 SUN 
- [X] this 강의 보기 => 자료구조까지 다 봄
- [ ] Linked List의 특성 알아보기
- [ ] VisuAlgo 사이트 Linked List 보기
- [ ] 1. 생활코딩 Linked List 강의 보기
- [ ] underdash 적혀있는 글들 1개 번역해보기



## 자료구조 
1. Stack 
- Last-In First-Out 
- push, pop 
- 후입선출 

- Big O 시간 복잡도 
- Insertion: O(1) : 항상 일관된 시간 
- Deletion: O(1)
- Search: O(n) : 스택의 개수에 시간이 비례한다. 

- Undo/Redo 메커니즘
- 뒤로가기/앞으로가지 메커니즘
- Call Stack

2. Queue 
- 사람들이 줄 선 것 같은
- Enqueue : 큐에 자료가 추가되는 작업
- Dequeue : 큐에 자료가 빼는 작업 
- First-In First-Out

- Big O 
- Insertion: O(1)
- Deletion: O(1)
- Search: O(n)

O(1)은 단지 일관된다는 의미 O(1)이 best가 아닐 수도 있다. 

3. Linked List 연결 리스트 
- LinkedList is made of a bunch of nodes that point to the next one in the list.
- 다음 녀석에 대한 point를 기억하고 있다. 이전 point에 대한 point가 없으면 head : tail구조 

- Big O
- Insertion: O(1)
- Deletion: O(1)
- Search: O(n)

Linked List vs Array List 
배열은 순서대로 줄섰다. Linked List는 내가 몇번짼진 모르지만 난 누구의 옆이다.. 즉 완전 다른 것 


[linked-list-vs-array](https://www.geeksforgeeks.org/linked-list-vs-array/)<br>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Arrays-1.png"><br>
Data storage scheme of an array

<img src="https://media.geeksforgeeks.org/wp-content/uploads/Linkedlist-2.png"><br>
Data storage scheme of a linked list

## Linked list 
link : 연결 
Data Structure의 미션은 메모리의 효율적 사용이다. 
메모리에도 address가 있다. 각각의 위치에 data가 있다. 각각의 주소에 접근할 때 걸리는 시간이 동일하다. : Random Access Memory

메모리를 사용하는 방법에 큰 차이가 있다. 
연속적으로 붙어있는 특성 
흩어져있는 특성. 흩어져있지만 연결되어 있다. 

[생활코딩](https://opentutorials.org/module/1335/8821)<br>
<img src="https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2903.png">

Linked List는 연결되어있다는 특성을 가지기 때문에 element라는 이름 대신에 vertex 또는 node라는 이름을 즐겨 사용한다.  

<img src="https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2939.png"><br>
첫번째 노드가 무엇인지 알 수 있어야 한다. : HEAD 

# 0404 MON
- [x] 2주차 과제 완료하기 
- [x] 코드 리뷰 받은 것 정리하고 코드 수정해보기 - 하는중 
- [ ] <https://www.youtube.com/watch?v=ayyuU0xdbIU&t=137s> this 강의 보기
- [x] 빅오 강의 보고 과제 시간복잡도 계산해보기 <https://www.youtube.com/watch?v=6Iq5iMCVsXA&t=329s>

[에어비앤비 코드](https://github.com/airbnb/javascript#comparison-operators--equality)


## 코드 리뷰 
1. indentation 신경쓰기
2. return 쓸 때는 한 줄 띄우고 쓰기
3. 일반적으로 if문에는 ; 쓰지 않는다.
4. rest 파라미터 활용하기. arguments로 접근하면 가독성이 좀 떨어지는 것 같다.. 
5. hasOwnProperty 메소드 사용하기
6. default parameters 라는 게 있군
7. 함수의 인자와 동일한 변수명 사용하는 것 피하기


```js
function multiply(a, b = 1) {
  return a * b;
}
```
7. arguments와 rest parameter 차이
8. 코드에 주석이 필요없게끔 코드의 가독성을 높히기
9. 커밋 내용 `[prifix]. 내용` 예) `add. part1 완료`
10. for...in 문과 for...of 의 차이
	- for...in문은 객체 자체의 모든 열거 가능한 속성들 뿐 아니라 프로토타입 체인으로부터 상속받은 속성들까지 모두 순회하기 때문에 의도치 않은 동작을 야기할 수 있다. 이를 막기 위해서 Object.prototype.hasOwnProperty() 메서드를 사용할 수 있다. 
11. 변수를 선언할 때는 무조건 const 키워드를 사용하고 나중에 변수 값을 재할당해야 하는 경우가 생기면 let 키워드로 수정하기. 




## 나머지 매개변수 rest 
함수가 정해지지 않은 수의 매개변수를 배열로 받을 수 있다. 

let linkedList;
linkedList = createLinkedList();

linkedList.addToTail(4);
    linkedList.addToTail(5);
linkedList.addToTail(6);



linkedList;


      // if(!list.head.next){
      //   list.head.next = node;
      //   list.tail = node;
      // }else { //head.next도 함께 구현해야 하는 것인가?


rest 파라미터 


for...of
이터레이터에 사용
순서보장 -> 굉장히 중요
배열 : 순서가 보장된다. 
객체같은 경우 순서가 보장되지 x

set으로 생성된 객체도 순회가 가능하다. 
for of : 순회 가능한 것들만 순회 가능하다. 
이터레이터만 순회할 수 있음. 
순회할 수 있는 애들은 이터레이터 프로토콜을 따른다. 
가장 흔한 이터레이터는 배열이다 

enumerable : 열거 가능한 : 순서 보장은 되지 않음
iterable : 순회 가능한

세미콜론 엣지케이스


Big O
알고리즘이 얼마나 효율적인지 측정하는 지표
n은 배열의 크기와 비례 



꼬리에 붙이는거 O(1)으로 

recursiveFunc

# 0405 TUE


1. [X] extend ...rest 사용해보기
2. [X] defaults  hasOwnProperty 사용해보기
2-2. [ ] defaults 함수가 지금 시간복잡도가 O(n^2) 인 것 같은데 더 낮출 수 있을까? 
3. [X] reduce each 사용해서 작성해보기
4. [X] reject filter 메서드 재사용하여 구현해보기
5. [X] map each 재사용하여 객체에도 대응할 수 있도록 리팩토링해보기
6. [ ] flatten 자체적으로 재귀 써보기 <https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#%EB%8C%80%EC%95%88>

- [X] 코드 리팩토링 해보기
- [ ] <https://www.youtube.com/watch?v=ayyuU0xdbIU&t=137s> this 강의 보기
- [ ] for...of , for...in 비교해보고 정리하기
	for...of 구문은 collection 전용이다. 모든 객체보다는 [Symbol.iterator] 속성이 있는 모든 컬렉션 요소에 대해 이 방식으로 반복한다. 
	- for...in문은 객체 자체의 모든 열거 가능한 속성들 뿐 아니라 프로토타입 체인으로부터 상속받은 속성들까지 모두 순회하기 때문에 의도치 않은 동작을 야기할 수 있다. 이를 막기 위해서 Object.prototype.hasOwnProperty() 메서드를 사용할 수 있다. 

```js
Object.prototype.objCustom = function () {};
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = "hello";

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
```
for...in문을 사용한 걸 보면 프로토타입 체인으로부터 상속받은 속성들까지 출력하고 있는 걸 볼 수 있다.


- 이것들 다 하고나서 다른 분들 코드 리뷰 보기

- 리팩토링 하려면 이 코드들에 대해서 다 이해하고 있어야 한다는 생각... 영어부터 번역을 해야겠다.


- arguments 사용하지 말 것 대신 ... 사용하기


# 0406 WED
- [x] 과제 리팩토링 정리하기
- [x] 보너스 과제 시작
- [ ] throttle 정리하기
- [ ] 가능하면 debounce도 정리하기
throttle이 대체 무엇이냐.... 
일정 시간 동안 요청이 한 번만 수행되도록 한다. 
스로틀은 다른 함수를 반환하는 함수인 고차함수다. 



## throttle 함수
```js
// Pass in the callback that we want to throttle and the delay between throttled events
// 조절하려는 콜백과 조절된 이벤트 사이의 지연을 전달합니다.
const throttle = (callback, delay) => {
  // 변수 주위에 클로저를 만듭니다.
  // 스로틀에서 처리하는 모든 이벤트에서 공유됩니다.
  let throttleTimeout = null;
  let storedEvent = null;

  // 스로틀이 활성 상태일 때 이벤트 및 스로틀 콜백을 처리하는 함수입니다.
  const throttledEventHandler = (event) => {
    // 매 반복마다 저장된 이벤트 업데이트
    storedEvent = event;

    // 스로틀이 활성화되지 않은 경우 이벤트와 함께 콜백을 실행합니다
    const shouldHandleEvent = !throttleTimeout;

    // 활성화된 스로틀이 없으면 콜백을 실행하고 새 스로틀을 생성합니다.
    if (shouldHandleEvent) {
      // Handle our event
      callback(storedEvent);

      // 저장된 이벤트를 사용했기 때문에 무효화합니다.
      storedEvent = null;

      // 지연 동안 이벤트를 처리하지 않도록 시간 초과를 설정하여 새 스로틀을 만듭니다.
      // 타임아웃이 끝나면 저장된 이벤트가 있는 경우 스로틀을 실행합니다.
      throttleTimeout = setTimeout(() => {
        // 스로틀 시간이 만료되었으므로 즉시 throttleTimeout을 무효화합니다.
        throttleTimeout = null;

        // 저장된 이벤트가 있는 경우 이 함수를 재귀적으로 호출합니다.
        // 재귀를 사용하면 이벤트가 있는 동안 계속 실행할 수 있습니다.
        // 이벤트 수신이 중지되면 스로틀이 종료됩니다.
        // 그런 다음 새 이벤트가 발생하면 즉시 실행됩니다.
        if (storedEvent) {
          // 시간 초과가 완료되면 다음을 수행합니다.:
          // 1. 이 재귀 호출은 throttleTimeout이 이제 null이므로 즉시 `콜백`을 실행합니다.
          // 2. 스로틀 타이머를 다시 시작하여 스로틀 프로세스를 반복할 수 있습니다.
          throttledEventHandler(storedEvent);
        }
      }, delay);
    }
  };
<https://skilled.dev/course>


  // 조절된 이벤트 핸들러를 클로저로 반환
  return throttledEventHandler;
};
```


`Function.prototype.apply()`  
apply() 메서드는 주어진 this 값과 배열 (또는 유사 배열 객체) 로 제공되는 arguments로 함수를 호출함

### vscode 
ctrl + shift + L : 같은 단어 선택  
alt + a : 브라켓 선택


# 0407 THU
- 오늘의 잡담  
정리를 하면서 진도를 나가야 할 것 같다. 이거 하다가 이거 하고 .. 이렇게 하니까 너무 정신이 없는 느낌
이번 주 과제를 하면서 느낀점은 과제를 하고서 끝내버리면 안되고 계속 어떻게 개선해야할지 고민해야 정말 내 것이 되는 것 같다. 여기서 어떻게 더 개선해야 좀 더 나은 코드가 될 수 있을까 고민하는 과정에서 얻는 것이 굉장히 많다는 걸 알게됐다. 그리고 정리를 하지 않고 지나가면 다음 과제가 너무나도 힘들 것 같다.  

- [X] for...in , for...of 정리 (이건 for문을 모두 모아서 한 번에 정리하자) -> 5시까지 (5시 10분 완료)
- [X] enumerable 공부 (5시 40분까지) -> (5시 35분 완료)
- [X] iterator 공부 (6시까지) -> (6시 24분 완료 밥먹고 산책하고 와야딩)
- [X] hasOwnProperty 에 대해서 아직 잘 모르는 것 같다.
- [X] favicon 달기 (9시 30분까지) -> (9시 43분 완료)
- [X] this 강의 보기. 강의 퀴즈문제를 아직 못풀었다. 풀 수 있는 만큼 공부하기. (PART3 10시 30분까지) => (10시 15분 완료) (~PART6 11시까지) -> (11시 7분 완료)
- [X] this 정리하기 (11시 30분까지) -> (11시 36분 완료)
- [X] target, current target 찾아보기 (11시 50분까지) -> (11시 43분 완료)
	- currentTarget은 이벤트 핸들러(이벤트 리스너)가 부착된 것. event.target은 이벤트가 발생한 요소를 반환하고 event.currentTarget은 이벤트를 등록해 놓은 요소를 반환한다. 
- [X] 강의 this 퀴즈 풀기 


- object에서 편했던 것 
- for...in
- for(const [key, value] of Object.entries(collection))
- Object.assign()

- 함께 해야할 것
1. 프로젝트 
	- 썸네일 제작하는 사이트를 만들고 싶다.
2. 자료구조, 알고리즘 공부 + 알고리즘 문제 풀기
	- [코딩테스트 광탈 방지 A to Z : JavaScript](https://programmers.co.kr/learn/courses/13213#qna) 강의 보기
	- leetcode? 
3. 블로그 만들기 
	- <https://miryang.dev/> 너무 멋있어. 
	- 블로그 구조 : nav bar에는 home, projects, about
	- 메뉴도 있었으면 좋겠군. 

# 0409 SAT
- [X] 오피스아워 보기 (4시 30분까지) -> (5시 10분 완료)
- [X] 프로토타입 강의 보기 Family oriented (6시까지) -> (5시 52분 완료)
- [X] Deep dive into prototype 강의 보기 (6시 30분까지)
- [X] Prototype Quiz 강의 보기 (8시까지) -> (8시 10분 완료)
- [X] Inheritance in JavaScript 강의 보기(9시 10분까지) -> (9시 15분 완료)
- [X] Hash table 강의보기 (10시까지) -> (9시 50분 완료)
- [X] 프로그래머스 해시 테이블 강의 보기 (10시까지) -> (10시 완료)
- [X] <https://www.youtube.com/watch?v=Vi0hauJemxA> 보기 (10시 15분까지) -> (11시 완료)
  - F(key) -> HashCode -> Index -> Value
  - 입력받은 key -> 해시알고리즘을 통해 해시코드 만들기 
  - 고정된 크기의 배열을 미리 선언 
- [] 과제 시작하기 (12시 30분까지 과제 이해하기)

자료구조 중요.
최선의 코드를 작성하려 노력해야 한다. 시간복잡도를 계산해야함
이진트리 -> 삽입 삭제가 log n으로 구현 
가비지컬렉터, 메모리 누수 - addEventListener 

Family Oriented Prototype 가족지향적인 프로토타입
정의)
원형; 견본, 전형


Constructor function 생성자 함수 
- 일반적으로 함수명 : 명사
- 첫글자를 대명사 
- return이 없어도 this를 리턴해준다. 

각 함수가 소유한 'prototype'객체는 해당 함수가 생성자 함수로서 실행될 때 특별한 역할을 하도록 설계되어 있다. 

생성자 함수가 반환해주는 빈 객체는 흔히 Instance 라고 부름
```js
function Person(name) {
  this.name = name;
}

const ken = new Person("ken");
```
ken은 Person의 인스턴스 

자바스크립트의 모든 인스턴스 객체는 해당 객체의 프로토타입에 존재하는 속성 및 메소드에 접근하여 사용할 수 있다. 

생성자 함수는 남편, prototype은 아내, constructor도 남편. instance는 자식, `__proto__` : 엄마
`__proto__` (Dunder proto; 던더 프로토)에 대해서 알고 계신 것은 좋지만, 실제로 사용하지는 마세요.


## Object.create()
```js
var obj = { hello: 1 };
var ken = Object.create(obj);
obj를 ken의 프로토타입으로 
```

```js
function Animal () {
  this.eat = function () { console.log("EAT!"); };
}

Animal.prototype.sleep = function () { console.log("sleep"); };

function Human (name) {
  Animal.call(this);
  this.name = name;
}
```

```
Human.prototype은? 
{constructor: ƒ}
constructor: ƒ Human(name)
[[Prototype]]: Object
```

```js
function Animal () {
  this.eat = function () { console.log("EAT!"); };
}

Animal.prototype.sleep = function () { console.log("sleep"); };

function Human (name) {
  Animal.call(this);
  this.name = name;
}

Human.prototype = Object.create(Animal.prototype);
Human.prototype.constructor = Human;
```
```
Human.prototype은?
Animal {}[[Prototype]]: Object
```
: constructor가 없어져서 다시 Human 생성자 함수로 constructor를 맞춰주어야 한다.
`Human.prototype.constructor = Human;` 추가

```
Human.prototype은? 
Animal {constructor: ƒ}
constructor: ƒ Human(name)
[[Prototype]]: Object
```

## Hash table
- Hash란 ? 고기와 감자를 잘게 다져 요리한 것 ex) hash brown 
- 해시 테이블은 한정된 배열 공간에 key를 index로 변환하여 값들을 넣게 된다. 
- 키와 값을 받아 키를 해싱(Hasing)하여 나온 index에 값을 저장하는 선형 자료구조. 
- 해시테이블에서 가장 중요한 요소는 hashing function 입니다. 해시함수란 입력받은 값을 특정 범위 내 숫자로 변경하는 함수 
- 메모리 관점에서 자바스크립트는 하위 레벨의 언어인데요, 자바스크립트로 Hash Table을 직접 구현해서 사용하는 것은 기술적으로 거의 불가능합니다.
- we use javascript plain objects in the place of hash table. 해시테이블 대신 일반 객체를 사용함 (자바스크립트에 있는 plain object가 해시테이블을 이용해 구현됐고 해시테이블과 유사한 성격을 가졌다.)
- 보통 알고리즘 문제풀 때 해시테이블을 써야겠다 하면 보통 객체를 씀. 
- 빠르게 값을 찾아야하는 경우 해시 테이블을 사용하는 것이 좋다. 

const table = {};
table["key"] = 100;
table["key2"] = "Hello";

### Big O 
- Insertion : O(1)
- Deletion: O(1)
- Search: O(1)

hashing function 
랜덤한 위치를 지정해주기 때문에 순수한 걸 보존하기 어렵다. 
- Not suitable for ordered data
- Might need large space allocation 큰 공간할당이 필요할 수 있다.비효율적인 측면이 나올 수 있다. 
- hash function이 꼭 필요하다.

### What is hashing? 
- 아웃풋 사이즈가 정해져있다. 

### Hash Function
- 해쉬함수를 구현하실 때 멱등성(Input ouput 결과가 달라지지 않아야함)을 유지해야 한다. 즉, 해쉬함수는 동일한 입력값에 대해 동일한 해쉬값을 반환해야만 합니다.
- 해쉬 함수란 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑, 변환 해주는 함수입니다. 매핑 전의 값을 키(key), 매핑 된 후의 값을 해시 값(hash value) 이 과정을 통틀어 해싱(hashing)이라 합니다.
- good distribution of values를 가져야한다. 
- performant를 가져야한다.

## 실제 사용사례 
- 주소록
- 블록체인 

1. helper function이 무슨 일을 하는지 파악 
  - helper function인 createLimitedArray()를 console.log 에 찍어보니 get, set, each 기능을 구현하고 조건에 맞지 않으면 error를 내뱉는 역할을 하는 것 같다.
2. 이미 주어진 hash function으로 key value를 array index value로 변경
3. 
이미 주어진 hash function을 가지고 key value를 array index value로 변경할 것입니다.


# 0410 SUN 
- [ ] 과제 완료하기 - 한 문제 남았다. 
- [ ] HASH TABLE 포스트 써보자 써보자! 
