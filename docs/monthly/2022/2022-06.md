# 목표
- [ ] 영어공부 주 3회 이상 꾸준히
- [ ] 쉐어하우스 계약하기
- [ ]	Leetcode Learn - Linked List 다 하기
- [ ] javascript30 다 만들어보기
- [ ] <https://ko.reactjs.org/tutorial/tutorial.html> 리액트 공식문서 읽기
- [ ] react Router v6 + <Link></Link> + useParams() 관계 / props 이해
- [ ] 처음 만난 리액트(React) 보기
- [ ] 만들면서 배우는 리액트 : 기초
- [ ] <https://www.youtube.com/watch?v=2jwnbZKc66E&list=PLSK4WsJ8JS4cQ-niGNum4bkK_THHOizTs> 이것도 해보고싶음
- [ ] 글쓰기 특강 요약, 정리 해보기
- [ ] 한주마다 컴퓨터 구조와 프로그래밍 한 챕터씩 읽기
- [ ] 아가미 읽기
- [ ] 알고리즘 강의 다 보고 정리
- [ ] 클린코드 강의 다 보고 정리
- [ ] 스터디 열심히
- [ ] DOM 공부하기

# 읽을 것
- [ ] [다시 쓰는 함수형 프로그래밍](https://velog.io/@teo/functional-programming)

# 0601 WED
- [X] parallel promise로 바꿔보기
- [ ] waterfall promise로 바꿔보기
- [X] 영어공부
- [X] 6월 목표 세우기

# 0602 THU
- [X] waterfall promise로 바꿔보기
- [X] waterfall, parallel 블로그에 기록하기
- [X] 알고리즘 강의 섹션 4
- [X] 영어공부
- [X] 드럼키트 다 만들기라도 하기


## 문제 해결 접근법
기본 접근 방식
알고리즘은 특정 작업을 달성하기 위한 과정이나 일련의 단계를 의미할뿐이다.
프로그래밍에서 수행하는 거의 모든 작업에는 아주 기본적인 작업이든 복잡한 애플리케이션을 구축하든 일종의 알고리즘이 포함되므로 문제를 해결할 방법을 마련할 수 있도록 결정을 해야 한다.


1. 문제를 풀기 위한 계획 세우기 (문제를 세분화 하는 단계)
2. 일반적인 문제 해결 패턴을 파악하기

- Problem Solving Strategies
1. Understand the Problem
	- 문제를 내 방식대로 다시 생각할 수 있는가?
	- 문제가 어떤 입력값을 담고있는가?
		- 입력값이 정수인가 소수인가 부동소수점인가
		- 만약 입력값이 숫자일 때 숫자가 굉장히 큰 숫자일 경우에 자바스크립트는 Infinity를 반환한다.
	- 어떤 출력값이 나와야 하는가?
	- 입력값이 출력값을 결정할 수 있는가?
	- 문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있는가?

2. Explore Concrete Examples 구체적 예시 살펴보기
	- 간단한 예시로 시작하기 (입력값과 출력값의 순서대로 예시를 두세 개 작성해보기)
	- 가장 쉬운 사례 예시부터 더 복잡한 예시로
	- Explore Examples with Empty Inputs
		- 빈 입력값이 있는 예제를 살펴보는 것은 특히 유효하지 않은 입력값이 주어진 면접 상황에서 문제를 어떻게 해결해야 할지 해결 능력을 갖출 수 있도록 해준다.
	- 유효하지 않은 입력값이 주어진 예시를 살펴보는 것과 관련이 있다.
3. Break It Down
	- 과정을 먼저 기록해보기 (단계를 적어보기)
4. Solve/Simplify
	- 문제를 해결할 수 있다면 해결하고 해결할 수 없다면 더 단순한 문제를 해결하기
		- 다른 모든 것에 집중하기 위해 시간이 많이 소요되는 부분을 무시하기
	- 잠깐 동안 어려운 부분을 무시하고 단순한 해결책을 작성한 다음 다시 어려운 부분을 가능하다면 다시 통합시키는 것
5. Look back and Refactor
	- 목표를 달성하기 위해 노력하는 것이 중요
	- 결과를 다른 방식으로 도출할 수 있는가?
	- 한 눈에 보고 이해할 수 있는가?(해결책이 얼마나 직관적인가?)
	- 결과나 방법을 다른 문제에도 적용할 수 있는가?
	- 해결책의 성능을 향상시킬 수 있는가?
	- 회사에서 근무하는 경우 코드를 향상시킬 수 있는 다른 방법을 떠올릴 수 있는가? (코드 인덴팅 일관적이게)
	- 다른 사람들은 어떻게 문제를 해결하는가?

## 드럼
```js
const keyElement = document.querySelectorAll(".key");
let audio;

keyElement.forEach((key) => {
	key.addEventListener("click", function() {

    audio = new Audio(`../sounds/${key.children[1].textContent.toLowerCase()}.wav`);
    audio.play();
	});
});

window.addEventListener("keydown", function(e) {
	if (e.key === "a" || e.key === "A") {
    audio = new Audio("../sounds/clap.wav");
    audio.play();
	}
  if (e.key === "s" || e.key === "S") {
    audio = new Audio("../sounds/hihat.wav");
    audio.play();
	}
  if (e.key === "d" || e.key === "D") {
    audio = new Audio("../sounds/kick.wav");
    audio.play();
	}
  if (e.key === "f" || e.key === "F") {
    audio = new Audio("../sounds/openhat.wav");
    audio.play();
	}
  if (e.key === "g" || e.key === "G") {
    audio = new Audio("../sounds/boom.wav");
    audio.play();
	}
  if (e.key === "h" || e.key === "H") {
    audio = new Audio("../sounds/ride.wav");
    audio.play();
	}
  if (e.key === "j" || e.key === "J") {
    audio = new Audio("../sounds/snare.wav");
    audio.play();
	}
  if (e.key === "k" || e.key === "K") {
    audio = new Audio("../sounds/tom.wav");
    audio.play();
	}
  if (e.key === "l" || e.key === "L") {
    audio = new Audio("../sounds/tink.wav");
    audio.play();
	}
});
```
도랐엉 완전 손코딩함; 내일 다시 고쳐보기


# 0603 FRI
- [X] 한입 크기로 잘라 먹는 리액트 javascript 응용까지 (api 전까지 봄)
- [X] 영어 공부

복잡한 조건이 있는 조건문을 includes를 사용할 수 있다

## 비 구조화 할당, 구조분해 할당

```js
let arr = ["one", "two", "three"];

let [one, two, three] = arr;
let [one, two, three] = ["one", "two", "three"];
let [one, two, three, four = "four"] = ["one", "two", "three"]; // 기본값을 설정할 수 있다.
```
```js
// swap
let a = 10;
let b = 20;

const temp = a;
a = b;
b = temp;

[a, b] = [b, a] // 이렇게도 할 수 있다.
```
```js
// 객체의 비구조화 할당
// 순서가 아니라 key값을 기준으로 할당한다. (순서가 상관없다.)
let object = { one: "one", two: "two", three: "three" }

let one = object.one;
let two = object.two;
let three = object.three;


let { one, two, three } = object; // 이렇게 가능하다.
let { one = changeName, two, three } = object; // 이름을 바꿀 수도 있다.
```

## spread 연산자

```js
const cookie = {
	base: "cookie",
	madeIn: "korea",
}

const chocochipCookie = {
	base: "cookie",
	madeIn: "korea",
	toping: "chocochip",
}

const blueberryCookie = {
	base: "cookie",
	madeIn: "korea",
	toping: "blueberry",
}

const strawberryCookie = {
	base: "cookie",
	madeIn: "korea",
	toping: "strawberry",
}
// 중복이 많다

const cookie = {
	base: "cookie",
	madeIn: "korea",
}

const chocochipCookie = {
	...cookie,
	toping: "chocochip",
}

const blueberryCookie = {
	...cookie,
	toping: "blueberry",
}

const strawberryCookie = {
	...cookie,
	toping: "strawberry",
}

```

## 비동기
Thread : 일꾼
멀티스레드

비동기란?
- 논 블로킹 방식

비동기 함수의 결과값을 이용할 때는 콜백함수를 사용

JS 엔진 

Heap(메모리 할당) + Call Stack(코드 실행)

1. 프로그램 실행 시 Main Context 제일 먼저 콜스택에 들어옴

# 0604 SAT
- [X] 3시 위민후 코드세미나
- [X] 영어 공부
- [X] 운동
- [ ] 한입 크기로 잘라 먹는 리액트 node.js 까지

## API
손님 요리사 냉장고
클라이언트 서버 데이터베이스 

json placeholder 
무료로 api - 더미데이터를 응답해줌
fetch : api를 호출할 수 있도록 도와주는 내장함수 , 프로미스를 반환한다.
api 결과값을 그냥 반환하는 게 아니라 api 성공 객체 자체를 반환한다.

```js
async function getData() {
  let rawResponse = await fetch("https://jsonplaceholder.typicode.com/posts");
  let jsonResponse = await rawResponse.json();
  console.log(jsonResponse);
}

getData();
```

## Node.js
자바스크립트를 브라우저가 아닌 곳에서도 실행시킬 수 있도록 만든 것
자바스크립트이 실행환경이라고도 부른다.
웹서버도 만들 수 있게 되었다.
url : 웹서버의 주소

# 0605 SUN
- [X] 영어 테스트
- [X] 한입크기 리액트 node.js
- [ ] 한입크기 리액트 리액트 기초

## 모듈 export하고 불러오기
```js
const add = (a, b) => a + b;
const sub = (a, b) => a - b;

module.exports = {
	moduleName: "calc module",
	add: add,
	sub: sub,
};
```

```js
const calc = require("./calc");

console.log(calc.add(1, 2));
console.log(calc.add(1, 2));
console.log(calc.sub(1, 2));
```

npm : Node Package Manager
- Node.js의 패키지 관리 도구
- 누군가 따로 만들어놓은 node.js 모듈을 의미

## 리액트가 필요한 이유
- 중복 코드 
- 컴포넌트 기반의 UI 라이브러리 - "재사용"
- Virtual DOM : 가상의 돔 사용

웸팩 : 모듈 번들러 다수의 파일을 하나의 파일로 합쳐주는
보일러 플레이트 : 이미 세팅 완료된 패키지
npx

# 0606 MON
- [X] simple-react gitlab 셋팅 (5시 까지)
- [X] 한입크기 리액트 리액트 기초 (7시 까지)
- [X] 제로초님 리액트 강의 1-3까지
- [X] 영어 공부

1. git fork
2. git clone
3. git remote add : 원격 저장소 등록
4. git fetch
5. git merge

### git push origin master에서 origin, master는 무엇을 의미?
- origin
	- original repository's URL 대신 사용한다고 한다.
	- In Git, "origin" is a shorthand name for the remote repository that a project was originally cloned from. More precisely, it is used instead of that original repository's URL - and thereby makes referencing much easier.

- master
	- 저장소를 처음 생성할 때 git이 생성하는 기본 브랜치의 이름. 대부분의 경우 "master"의 의미는 "the main branch"를 의미한다.


index.js 최상위 컴포넌트를 정의할 수 있다.

## JSX
- 닫힘 태그가 필요
- 최상위 태그 규칙 -> 반드시 하나의 부모를 가져야한다. fragment 쓸 수 있다.(import React 필요) `<React.Fragment>` 또는 `<></>`
- class -> className

```js

function App() {
  let name = "alex";

  const style = {
    App: {
      backgroundColor: "black",
    },
    h2: {
      color: "red",
    },
    b: {
      color: "green",
    },
  }

  return (
    <div style={style.App}>
      <MyHeader />
      <h2 style={style.h2}>안녕 리액트 {name}</h2>
      <b style={style.b}>React.js</b>
    </div>
  );
}
```
객체로 스타일을 줄 수도 있다.

jsx의 중괄호안에는 배열, boolean은 표시가 안됨. 숫자나 문자열, 식만 포함할 수 있다.

```js
  const number = 5;

  return (
    <div style={style.App}>
      <MyHeader />
      <h2 style={style.h2}>안녕 리액트 {name}</h2>
      <b style={style.b}>
        {number}는 : {number % 2 === 0 ? "짝수" : "홀수"}
      </b>
    </div>
  );
```
삼항 연산자도 사용 가능 (조건부 렌더링이라고 함)

## 상태 State
계속해서 변화하는 특정 상태
상태에 따라 각각 다른 동작을 함

컴포넌트가 가진 state가 바뀌면 재렌더를 한다. (리렌더)

```js
const Counter = () => {

	const [count, setCount] = useState(0);
	const onIncrease = () => {
		setCount(count + 1);
	}
	const onDecrease = () => {
		setCount(count - 1);
	}
	return (
		<div>
			<h2>{count}</h2>
			<button onClick={onIncrease}>+</button>
			<button onClick={onDecrease}>-</button>
		</div>
	)
}
```

## props
```js
function App() {
  const number = 5;

  const counterProps = {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: 5,
    initialValue: 5,
  }

  return (
    <div>
      <MyHeader />
      <Counter initialValue={5} />
      <Counter {...counterProps} />
    </div>
  );
}
```
`initialValue={5}` 이런식으로 넣어도 되고 객체안에 추가해서 넣어도 되고

```js
import React, {useState} from "react";


const Counter = (props) => {
	console.log(props)

	const [count, setCount] = useState(0);
	const onIncrease = () => {
		setCount(count + 1);
	}
	const onDecrease = () => {
		setCount(count - 1);
	}
	return (
		<div>
			<h2>{count}</h2>
			<button onClick={onIncrease}>+</button>
			<button onClick={onDecrease}>-</button>
		</div>
	)
}
```
전달 받을 땐 저렇게 한번에 가져와도 되고, const Counter = ({ initialValue }) 이렇게 들고와도 됨
defaultProps로 기본값 설정할 수 있음  
props는 정적인 데이터 뿐 아니라 동적인 데이터도 전달할 수 있음


### 컴포넌트 자체도 전달할 수 있다
```js
const Container = ({ children }) => {
	return (
		<div style={{ margin: 20, padding: 20, border: "1px solid gray" }}>
			{children}
		</div>
	);
}

export default Container;
```

```js
function App() {
  const number = 5;

  const counterProps = {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: 5,
    initialValue: 5,
  }

  return (
    <Container>
      <div>
        <MyHeader />
        <Counter {...counterProps} />
      </div>
    </Container>
  );
}
```
이렇게 되면 Container의 `children`은 App()의 Container 사이의 것들이 된다.


싱글 페이지 어플리케이션  
리액트도 결국엔 자바스크립트다  
state : data  
리액트는 데이터 중심으로 움직인다. (데이터와 화면의 일치)  
컴포넌트 : 데이터, 화면을 하나로 묶어놓은 것  
화면에 바뀔 부분을 state로 만든다  
결과물은 html, css, javascript가 나와야 웹에서 읽어드릴 수 있다.  

1. class 방식
2. 함수 방식 (화살표 함수)

### class
class가 계속 헷갈려서 다시 짚고 넘어가보려고 한다.
[클래스와 기본 문법](https://ko.javascript.info/class)  
mdn보다 여기가 훨씬 이해가 잘된다.
class 문법에서는 class, constructor, extends, super와 같은 단어가 있는데 하나씩 살펴보도록 하자

class는 문법의 한 종류인 것 같다.(함수의 한 종류라고) 객체지향프로그래밍에서 흔히 쓰는 거라고 함
class에 정의된 메소드는 열거할 수 없다. enumerable 플래그 : false  
class는 항상 엄격 모드로 실행된다.
constructor는 생성자 메서드이다. new에 의해 자동으로 호출된다.
class로 생성된 인스턴스 객체를 생성하고 초기화하기 위한 특수한 메서드.  
클래스 안에 한 개만 존재할 수 있다.

```js
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
}
alert(typeof User); // function
let user = new User("John");
user.sayHi();
```
`new User("John")`를 호출하면 밑과 같은 일이 일어난다.
1. 새로운 객체가 생성된다.
2. 넘겨받은 인수 "John"과 함께 constructor("John")이 실행됨. 이때 인수 "John"이 this.name에 할당된다.

이런 과정을 거친 후에 user.sayHi() 같은 객체 메서드를 호출할 수 있다.

#### class 문법 구조가 하는 일
1. User라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 constructor에서 가져옴. 생성자 메서드가 없으면 본문이 비워진채로 함수가 만들어짐
2. sayHi같은 클래스 내에서 정의한 메소드를 User.prototype에 저장함

User 에는 constructor가 있고 User.prototype에는 sayHi메서드와 constructor(User)가 있다.

#### 정리
```js
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// 클래스는 함수입니다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일합니다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장됩니다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개입니다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

### class 상속 - extends, super
[클래스 상속](https://ko.javascript.info/class-inheritance)


```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} 은/는 속도 ${this.speed}로 달립니다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} 이/가 멈췄습니다.`);
  }
}

let animal = new Animal("동물");
```
```js
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} 이/가 숨었습니다!`);
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼 은/는 속도 5로 달립니다.
rabbit.hide(); // 흰 토끼 이/가 숨었습니다!
```
extends를 사용하면 Animal의 메서드를 Rabbit에서도 상속받아 사용할 수 있다.
Rabbit에서 Animal에 있는 메서드를 오버라이딩 할 수 있는데 만약 덮어쓰기 한 후에 다시 Animal에 있는 메서드가 필요하다면  
__super__ 를 사용하면 된다.
- super.method(...)는 부모 클래스에 정의된 메서드, method를 호출합니다.
- super(...)는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용 할 수 있습니다.


`React.createElement` 방식을 JSX 방식으로 바꿔줌
JSX
- 바벨이 React.createElement로 바꿔준다.