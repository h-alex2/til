# 목표
- [ ] 영어공부 주 3회 이상 꾸준히
- [ ] 쉐어하우스 계약하기
- [ ]	Leetcode Learn - Linked List 다 하기
- [ ] javascript30 다 만들어보기
- [ ] <https://ko.reactjs.org/tutorial/tutorial.html> 리액트 공식문서 읽기
- [ ] react Router v6 + <Link></Link> + useParams() 관계 / props 이해
- [ ] 처음 만난 리액트(React) 보기
- [ ] 만들면서 배우는 리액트 : 기초
- [ ] <https://www.youtube.com/watch?v=2jwnbZKc66E&list=PLSK4WsJ8JS4cQ-niGNum4bkK_THHOizTs> 이것도 해보고싶음
- [ ] 글쓰기 특강 요약, 정리 해보기
- [ ] 한주마다 컴퓨터 구조와 프로그래밍 한 챕터씩 읽기
- [ ] 아가미 읽기
- [ ] 알고리즘 강의 다 보고 정리
- [ ] 클린코드 강의 다 보고 정리
- [ ] 스터디 열심히
- [ ] DOM 공부하기

# 읽을 것
- [ ] [다시 쓰는 함수형 프로그래밍](https://velog.io/@teo/functional-programming)

# 0601 WED
- [X] parallel promise로 바꿔보기
- [ ] waterfall promise로 바꿔보기
- [X] 영어공부
- [X] 6월 목표 세우기

# 0602 THU
- [X] waterfall promise로 바꿔보기
- [X] waterfall, parallel 블로그에 기록하기
- [X] 알고리즘 강의 섹션 4
- [X] 영어공부
- [X] 드럼키트 다 만들기라도 하기


## 문제 해결 접근법
기본 접근 방식
알고리즘은 특정 작업을 달성하기 위한 과정이나 일련의 단계를 의미할뿐이다.
프로그래밍에서 수행하는 거의 모든 작업에는 아주 기본적인 작업이든 복잡한 애플리케이션을 구축하든 일종의 알고리즘이 포함되므로 문제를 해결할 방법을 마련할 수 있도록 결정을 해야 한다.


1. 문제를 풀기 위한 계획 세우기 (문제를 세분화 하는 단계)
2. 일반적인 문제 해결 패턴을 파악하기

- Problem Solving Strategies
1. Understand the Problem
	- 문제를 내 방식대로 다시 생각할 수 있는가?
	- 문제가 어떤 입력값을 담고있는가?
		- 입력값이 정수인가 소수인가 부동소수점인가
		- 만약 입력값이 숫자일 때 숫자가 굉장히 큰 숫자일 경우에 자바스크립트는 Infinity를 반환한다.
	- 어떤 출력값이 나와야 하는가?
	- 입력값이 출력값을 결정할 수 있는가?
	- 문제의 일부인 데이터의 중요한 부분에 어떻게 라벨을 지정할 수 있는가?

2. Explore Concrete Examples 구체적 예시 살펴보기
	- 간단한 예시로 시작하기 (입력값과 출력값의 순서대로 예시를 두세 개 작성해보기)
	- 가장 쉬운 사례 예시부터 더 복잡한 예시로
	- Explore Examples with Empty Inputs
		- 빈 입력값이 있는 예제를 살펴보는 것은 특히 유효하지 않은 입력값이 주어진 면접 상황에서 문제를 어떻게 해결해야 할지 해결 능력을 갖출 수 있도록 해준다.
	- 유효하지 않은 입력값이 주어진 예시를 살펴보는 것과 관련이 있다.
3. Break It Down
	- 과정을 먼저 기록해보기 (단계를 적어보기)
4. Solve/Simplify
	- 문제를 해결할 수 있다면 해결하고 해결할 수 없다면 더 단순한 문제를 해결하기
		- 다른 모든 것에 집중하기 위해 시간이 많이 소요되는 부분을 무시하기
	- 잠깐 동안 어려운 부분을 무시하고 단순한 해결책을 작성한 다음 다시 어려운 부분을 가능하다면 다시 통합시키는 것
5. Look back and Refactor
	- 목표를 달성하기 위해 노력하는 것이 중요
	- 결과를 다른 방식으로 도출할 수 있는가?
	- 한 눈에 보고 이해할 수 있는가?(해결책이 얼마나 직관적인가?)
	- 결과나 방법을 다른 문제에도 적용할 수 있는가?
	- 해결책의 성능을 향상시킬 수 있는가?
	- 회사에서 근무하는 경우 코드를 향상시킬 수 있는 다른 방법을 떠올릴 수 있는가? (코드 인덴팅 일관적이게)
	- 다른 사람들은 어떻게 문제를 해결하는가?

## 드럼
```js
const keyElement = document.querySelectorAll(".key");
let audio;

keyElement.forEach((key) => {
	key.addEventListener("click", function() {

    audio = new Audio(`../sounds/${key.children[1].textContent.toLowerCase()}.wav`);
    audio.play();
	});
});

window.addEventListener("keydown", function(e) {
	if (e.key === "a" || e.key === "A") {
    audio = new Audio("../sounds/clap.wav");
    audio.play();
	}
  if (e.key === "s" || e.key === "S") {
    audio = new Audio("../sounds/hihat.wav");
    audio.play();
	}
  if (e.key === "d" || e.key === "D") {
    audio = new Audio("../sounds/kick.wav");
    audio.play();
	}
  if (e.key === "f" || e.key === "F") {
    audio = new Audio("../sounds/openhat.wav");
    audio.play();
	}
  if (e.key === "g" || e.key === "G") {
    audio = new Audio("../sounds/boom.wav");
    audio.play();
	}
  if (e.key === "h" || e.key === "H") {
    audio = new Audio("../sounds/ride.wav");
    audio.play();
	}
  if (e.key === "j" || e.key === "J") {
    audio = new Audio("../sounds/snare.wav");
    audio.play();
	}
  if (e.key === "k" || e.key === "K") {
    audio = new Audio("../sounds/tom.wav");
    audio.play();
	}
  if (e.key === "l" || e.key === "L") {
    audio = new Audio("../sounds/tink.wav");
    audio.play();
	}
});
```
도랐엉 완전 손코딩함; 내일 다시 고쳐보기


# 0603 FRI
- [X] 한입 크기로 잘라 먹는 리액트 javascript 응용까지 (api 전까지 봄)
- [X] 영어 공부

복잡한 조건이 있는 조건문을 includes를 사용할 수 있다

## 비 구조화 할당, 구조분해 할당

```js
let arr = ["one", "two", "three"];

let [one, two, three] = arr;
let [one, two, three] = ["one", "two", "three"];
let [one, two, three, four = "four"] = ["one", "two", "three"]; // 기본값을 설정할 수 있다.
```
```js
// swap
let a = 10;
let b = 20;

const temp = a;
a = b;
b = temp;

[a, b] = [b, a] // 이렇게도 할 수 있다.
```
```js
// 객체의 비구조화 할당
// 순서가 아니라 key값을 기준으로 할당한다. (순서가 상관없다.)
let object = { one: "one", two: "two", three: "three" }

let one = object.one;
let two = object.two;
let three = object.three;


let { one, two, three } = object; // 이렇게 가능하다.
let { one = changeName, two, three } = object; // 이름을 바꿀 수도 있다.
```

## spread 연산자

```js
const cookie = {
	base: "cookie",
	madeIn: "korea",
}

const chocochipCookie = {
	base: "cookie",
	madeIn: "korea",
	toping: "chocochip",
}

const blueberryCookie = {
	base: "cookie",
	madeIn: "korea",
	toping: "blueberry",
}

const strawberryCookie = {
	base: "cookie",
	madeIn: "korea",
	toping: "strawberry",
}
// 중복이 많다

const cookie = {
	base: "cookie",
	madeIn: "korea",
}

const chocochipCookie = {
	...cookie,
	toping: "chocochip",
}

const blueberryCookie = {
	...cookie,
	toping: "blueberry",
}

const strawberryCookie = {
	...cookie,
	toping: "strawberry",
}

```

## 비동기
Thread : 일꾼
멀티스레드

비동기란?
- 논 블로킹 방식

비동기 함수의 결과값을 이용할 때는 콜백함수를 사용

JS 엔진 

Heap(메모리 할당) + Call Stack(코드 실행)

1. 프로그램 실행 시 Main Context 제일 먼저 콜스택에 들어옴

# 0604 SAT
- [X] 3시 위민후 코드세미나
- [X] 영어 공부
- [X] 운동
- [ ] 한입 크기로 잘라 먹는 리액트 node.js 까지

# 0605 SUN
- [X] 영어 테스트
- [X] 한입크기 리액트 node.js
- [ ] 한입크기 리액트 리액트 기초


# 0606 MON
- [X] simple-react gitlab 셋팅 (5시 까지)
- [X] 한입크기 리액트 리액트 기초 (7시 까지)
- [X] 제로초님 리액트 강의 1-3까지
- [X] 영어 공부

1. git fork
2. git clone
3. git remote add : 원격 저장소 등록
4. git fetch
5. git merge

### git push origin master에서 origin, master는 무엇을 의미?
- origin
	- original repository's URL 대신 사용한다고 한다.
	- In Git, "origin" is a shorthand name for the remote repository that a project was originally cloned from. More precisely, it is used instead of that original repository's URL - and thereby makes referencing much easier.

- master
	- 저장소를 처음 생성할 때 git이 생성하는 기본 브랜치의 이름. 대부분의 경우 "master"의 의미는 "the main branch"를 의미한다.


index.js 최상위 컴포넌트를 정의할 수 있다.



싱글 페이지 어플리케이션  
리액트도 결국엔 자바스크립트다  
state : data  
리액트는 데이터 중심으로 움직인다. (데이터와 화면의 일치)  
컴포넌트 : 데이터, 화면을 하나로 묶어놓은 것  
화면에 바뀔 부분을 state로 만든다  
결과물은 html, css, javascript가 나와야 웹에서 읽어드릴 수 있다.  

1. class 방식
2. 함수 방식 (화살표 함수)

### class
class가 계속 헷갈려서 다시 짚고 넘어가보려고 한다.
[클래스와 기본 문법](https://ko.javascript.info/class)  
mdn보다 여기가 훨씬 이해가 잘된다.
class 문법에서는 class, constructor, extends, super와 같은 단어가 있는데 하나씩 살펴보도록 하자

class는 문법의 한 종류인 것 같다.(함수의 한 종류라고) 객체지향프로그래밍에서 흔히 쓰는 거라고 함
class에 정의된 메소드는 열거할 수 없다. enumerable 플래그 : false  
class는 항상 엄격 모드로 실행된다.
constructor는 생성자 메서드이다. new에 의해 자동으로 호출된다.
class로 생성된 인스턴스 객체를 생성하고 초기화하기 위한 특수한 메서드.  
클래스 안에 한 개만 존재할 수 있다.

```js
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }
}
alert(typeof User); // function
let user = new User("John");
user.sayHi();
```
`new User("John")`를 호출하면 밑과 같은 일이 일어난다.
1. 새로운 객체가 생성된다.
2. 넘겨받은 인수 "John"과 함께 constructor("John")이 실행됨. 이때 인수 "John"이 this.name에 할당된다.

이런 과정을 거친 후에 user.sayHi() 같은 객체 메서드를 호출할 수 있다.

#### class 문법 구조가 하는 일
1. User라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드 constructor에서 가져옴. 생성자 메서드가 없으면 본문이 비워진채로 함수가 만들어짐
2. sayHi같은 클래스 내에서 정의한 메소드를 User.prototype에 저장함

User 에는 constructor가 있고 User.prototype에는 sayHi메서드와 constructor(User)가 있다.

#### 정리
```js
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// 클래스는 함수입니다.
alert(typeof User); // function

// 정확히는 생성자 메서드와 동일합니다.
alert(User === User.prototype.constructor); // true

// 클래스 내부에서 정의한 메서드는 User.prototype에 저장됩니다.
alert(User.prototype.sayHi); // alert(this.name);

// 현재 프로토타입에는 메서드가 두 개입니다.
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

### class 상속 - extends, super
[클래스 상속](https://ko.javascript.info/class-inheritance)


```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} 은/는 속도 ${this.speed}로 달립니다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} 이/가 멈췄습니다.`);
  }
}

let animal = new Animal("동물");
```
```js
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} 이/가 숨었습니다!`);
  }
}

let rabbit = new Rabbit("흰 토끼");

rabbit.run(5); // 흰 토끼 은/는 속도 5로 달립니다.
rabbit.hide(); // 흰 토끼 이/가 숨었습니다!
```
extends를 사용하면 Animal의 메서드를 Rabbit에서도 상속받아 사용할 수 있다.
Rabbit에서 Animal에 있는 메서드를 오버라이딩 할 수 있는데 만약 덮어쓰기 한 후에 다시 Animal에 있는 메서드가 필요하다면  
__super__ 를 사용하면 된다.
- super.method(...)는 부모 클래스에 정의된 메서드, method를 호출합니다.
- super(...)는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용 할 수 있습니다.


`React.createElement` 방식을 JSX 방식으로 바꿔줌
JSX
- 바벨이 React.createElement로 바꿔준다.

# 0607 TUE
- [X] 영어 공부
- [X] 리액트 공식문서 - 단계별 가이드 (7까지 봄)
  - <https://h-alex2.github.io/til/#/react/react> 정리함
- [X] 제로초님 리액트 강의 5강까지
- [X] 한입 크기 리액트 React 기본 - 배열까지
  - <https://h-alex2.github.io/til/#/react/한입강의> 여기에 기록
- [ ] 코스모스 100페이지 까지 읽기 (30페이지 까지 읽음)
- [X] 컴터책 웹브라우저 부분 읽기
- [ ] [Pete Hunt: React: Rethinking best practices -- JSConf EU](https://www.youtube.com/watch?v=x7cQ3mrcKaY)
- [X] 운동


### class 리액트 작성
```html
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<!--<script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>-->
<!--<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>-->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
  'use strict';

  const e = React.createElement;

  class LikeButton extends React.Component {
    constructor(props) {
      super(props);
      this.state = {liked: false};
    }

    render() {
      if (this.state.liked) {
        return 'You liked this.';
      }

      return e('button', {onClick: () => this.setState({liked: true})}, 'Like');
    }
  } 
</script>
<script type="text/babel">
  ReactDOM.createRoot(document.querySelector('#root')).render(e(LikeButton));
</script>
```

- 바벨을 써서 밑과 같이 바꿀 수 있다.

```html
<script type="text/babel">
  'use strict';

  const e = React.createElement;

  class LikeButton extends React.Component {
    constructor(props) {
      super(props);
      this.state = {liked: false};
    }

    render() {
      if (this.state.liked) {
        return 'You liked this.';
      }

			return (
				<button onClick={() => this.setState({liked: true})}>
					Like
				</button>
			)

      // return e(
			// 	'button',
			// 	{onClick: () => this.setState({liked: true})},
			// 	'Like'
			// );
    }
  }
</script>
<script type="text/babel">
	ReactDOM.render(<LikeButton />, document.querySelector("#root"));
</script>
</body>
</html>
```

## react 18버전으로 업그레이드 되면서 render가 createRoot로 변경됨
```html
<script type="text/babel">
	ReactDOM.createRoot(document.querySelector("#root")).render(<LikeButton />); //리액트 18버전
	// ReactDOM.render(<LikeButton />, document.querySelector("#root")); // 리액트 17버전 코드
</script>
```
- 하지만 17버전을 사용하는 곳도 많을 것. 둘 다 알아야 함


### 객체를 직접적으로 바꾸면 XXX
```js
  return (
    <button onClick={() => {
      this.setState({liked: true})
      this.state.liked = true; //이렇게 바꾸면 안됨. state를 바꿀 수 있는 방법으로는 위의 방법 setState
    }}>
      Like
    </button>
  )
```

# 0608 WED
- [X] 한입 리액트 리액트 기본까지
- [X] 드럼 고치고 리액트로 해보기 (고치기만 함)
```js
const keyElement = document.querySelectorAll(".key");
let audio;

keyElement.forEach((key) => {
	key.addEventListener("click", function() {
    audio = new Audio(`../sounds/${key.children[1].textContent.toLowerCase()}.wav`);
    audio.play();
	});
});

window.addEventListener("keydown", function(e) {
  const audio = document.querySelector(`audio[data-key=${e.key}]`)
  const key = document.querySelector(`div[data-key=${e.key}]`)
  if (!audio) return;
  audio.currentTime = 0; //되감기
  audio.play();

  key.classList.add("playing");

  setTimeout(() => {
    key.classList.remove("playing");
  }, 100)
});
```
진행중  
강의에서는 transitioned 이벤트 리스너 사용하는데 이걸로 다시 해보기
- [X] 심플 리액트 시작
- [ ] 리액트 공식문서 - 단계별 가이드
- [ ] 영어공부
- [X] 코스모스 60페이지까지